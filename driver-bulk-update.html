<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bulk API - MongoDB Driver Specifications</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="driver-mantras.html">Mantras</a></li><li class="chapter-item expanded affix "><li class="part-title">Specifications</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Serialization</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="BSON.html"><strong aria-hidden="true">1.1.</strong> BSON</a></li><li class="chapter-item expanded "><a href="objectid.html"><strong aria-hidden="true">1.2.</strong> ObjectId</a></li><li class="chapter-item expanded "><a href="bson-decimal128/decimal128.html"><strong aria-hidden="true">1.3.</strong> Decimal128</a></li><li class="chapter-item expanded "><a href="uuid.html"><strong aria-hidden="true">1.4.</strong> UUID</a></li><li class="chapter-item expanded "><a href="dbref.html"><strong aria-hidden="true">1.5.</strong> DBRef</a></li><li class="chapter-item expanded "><a href="extended-json.html"><strong aria-hidden="true">1.6.</strong> Extended JSON</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Communication</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="message/OP_MSG.html"><strong aria-hidden="true">2.1.</strong> OP_MSG</a></li><li class="chapter-item expanded "><a href="run-command/run-command.html"><strong aria-hidden="true">2.2.</strong> Command Execution</a></li><li class="chapter-item expanded "><a href="connection-string/connection-string-spec.html"><strong aria-hidden="true">2.3.</strong> Connection String</a></li><li class="chapter-item expanded "><a href="uri-options/uri-options.html"><strong aria-hidden="true">2.4.</strong> URI Options</a></li><li class="chapter-item expanded "><a href="ocsp-support/ocsp-support.html"><strong aria-hidden="true">2.5.</strong> OCSP</a></li><li class="chapter-item expanded "><a href="mongodb-handshake/handshake.html"><strong aria-hidden="true">2.6.</strong> Initial Handshake</a></li><li class="chapter-item expanded "><a href="compression/OP_COMPRESSED.html"><strong aria-hidden="true">2.7.</strong> Wire Compression</a></li><li class="chapter-item expanded "><a href="socks5-support/socks5.html"><strong aria-hidden="true">2.8.</strong> SOCKS5</a></li><li class="chapter-item expanded "><a href="initial-dns-seedlist-discovery/initial-dns-seedlist-discovery.html"><strong aria-hidden="true">2.9.</strong> Initial DNS Seedlist Discovery</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Connectivity</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="server-discovery-and-monitoring/server-discovery-and-monitoring.html"><strong aria-hidden="true">3.1.</strong> Server Discovery and Monitoring</a></li><li class="chapter-item expanded "><a href="connection-monitoring-and-pooling/connection-monitoring-and-pooling.html"><strong aria-hidden="true">3.2.</strong> Connection Monitoring and Pooling</a></li><li class="chapter-item expanded "><a href="load-balancers/load-balancers.html"><strong aria-hidden="true">3.3.</strong> Load Balancer Support</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Availability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="server-discovery-and-monitoring/server-monitoring.html"><strong aria-hidden="true">4.1.</strong> Server Monitoring</a></li><li class="chapter-item expanded "><a href="polling-srv-records-for-mongos-discovery/polling-srv-records-for-mongos-discovery.html"><strong aria-hidden="true">4.2.</strong> SRV Polling for mongos Discovery</a></li><li class="chapter-item expanded "><a href="server-selection/server-selection.html"><strong aria-hidden="true">4.3.</strong> Server Selection</a></li><li class="chapter-item expanded "><a href="max-staleness/max-staleness.html"><strong aria-hidden="true">4.4.</strong> Max Staleness</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Resilience</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Retryability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="retryable-reads/retryable-reads.html"><strong aria-hidden="true">5.1.1.</strong> Reads</a></li><li class="chapter-item expanded "><a href="retryable-writes/retryable-writes.html"><strong aria-hidden="true">5.1.2.</strong> Writes</a></li></ol></li><li class="chapter-item expanded "><a href="client-side-operations-timeout/client-side-operations-timeout.html"><strong aria-hidden="true">5.2.</strong> CSOT</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Consistency</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="sessions/driver-sessions.html"><strong aria-hidden="true">5.3.1.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="causal-consistency/causal-consistency.html"><strong aria-hidden="true">5.3.2.</strong> Causal Consistency</a></li><li class="chapter-item expanded "><a href="sessions/snapshot-sessions.html"><strong aria-hidden="true">5.3.3.</strong> Snapshot Reads</a></li><li class="chapter-item expanded "><a href="transactions/transactions.html"><strong aria-hidden="true">5.3.4.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="transactions-convenient-api/transactions-convenient-api.html"><strong aria-hidden="true">5.3.5.</strong> Convenient Transactions API</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programmability</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Resource Management</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="enumerate-databases.html"><strong aria-hidden="true">6.1.1.</strong> Databases</a></li><li class="chapter-item expanded "><a href="enumerate-collections.html"><strong aria-hidden="true">6.1.2.</strong> Collections</a></li><li class="chapter-item expanded "><a href="index-management/index-management.html"><strong aria-hidden="true">6.1.3.</strong> Indexes</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Data Management</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="crud/crud.html"><strong aria-hidden="true">6.2.1.</strong> CRUD</a></li><li class="chapter-item expanded "><a href="collation/collation.html"><strong aria-hidden="true">6.2.2.</strong> Collation</a></li><li class="chapter-item expanded "><a href="server_write_commands.html"><strong aria-hidden="true">6.2.3.</strong> Write Commands</a></li><li class="chapter-item expanded "><a href="driver-bulk-update.html" class="active"><strong aria-hidden="true">6.2.4.</strong> Bulk API</a></li><li class="chapter-item expanded "><a href="crud/bulk-write.html"><strong aria-hidden="true">6.2.5.</strong> Bulk Write</a></li><li class="chapter-item expanded "><a href="read-write-concern/read-write-concern.html"><strong aria-hidden="true">6.2.6.</strong> R/W Concern</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Cursors</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="change-streams/change-streams.html"><strong aria-hidden="true">6.3.1.</strong> Change Streams</a></li><li class="chapter-item expanded "><a href="find_getmore_killcursors_commands.html"><strong aria-hidden="true">6.3.2.</strong> find/getMore/killCursors</a></li></ol></li><li class="chapter-item expanded "><a href="gridfs/gridfs-spec.html"><strong aria-hidden="true">6.4.</strong> GridFS</a></li><li class="chapter-item expanded "><a href="versioned-api/versioned-api.html"><strong aria-hidden="true">6.5.</strong> Stable API</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.6.</strong> Security</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="client-side-encryption/client-side-encryption.html"><strong aria-hidden="true">6.6.1.</strong> Client Side Encryption</a></li><li class="chapter-item expanded "><a href="client-side-encryption/subtype6.html"><strong aria-hidden="true">6.6.2.</strong> BSON Binary Subtype 6</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Observability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="command-logging-and-monitoring/command-logging-and-monitoring.html"><strong aria-hidden="true">7.1.</strong> Command Logging and Monitoring</a></li><li class="chapter-item expanded "><a href="server-discovery-and-monitoring/server-discovery-and-monitoring-logging-and-monitoring.html"><strong aria-hidden="true">7.2.</strong> SDAM Logging and Monitoring</a></li><li class="chapter-item expanded "><a href="logging/logging.html"><strong aria-hidden="true">7.3.</strong> Standardized Logging</a></li><li class="chapter-item expanded "><a href="connection-monitoring-and-pooling/connection-monitoring-and-pooling.html"><strong aria-hidden="true">7.4.</strong> Connection Pool Logging</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Testability</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="unified-test-format/unified-test-format.html"><strong aria-hidden="true">8.1.</strong> Unified Test Format</a></li><li class="chapter-item expanded "><a href="atlas-data-lake-testing/tests/index.html"><strong aria-hidden="true">8.2.</strong> Atlas Data Federation Testing</a></li><li class="chapter-item expanded "><a href="benchmarking/benchmarking.html"><strong aria-hidden="true">8.3.</strong> Performance Benchmarking</a></li><li class="chapter-item expanded "><a href="bson-corpus/bson-corpus.html"><strong aria-hidden="true">8.4.</strong> BSON Corpus</a></li><li class="chapter-item expanded "><a href="connections-survive-step-down/tests/index.html"><strong aria-hidden="true">8.5.</strong> Replication Event Resilience</a></li><li class="chapter-item expanded "><a href="faas-automated-testing/faas-automated-testing.html"><strong aria-hidden="true">8.6.</strong> FAAS Automated Testing</a></li><li class="chapter-item expanded "><a href="serverless-testing/index.html"><strong aria-hidden="true">8.7.</strong> Atlas Serverless Testing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MongoDB Driver Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1>=============
Bulk API Spec</h1>
<p>:Status: Deprecated
:Minimum Server Version: 2.4</p>
<p>.. contents::</p>
<h1 id="bulk-operation-builder"><a class="header" href="#bulk-operation-builder">Bulk Operation Builder</a></h1>
<p>Starting a bulk operation can be done in two ways.</p>
<p>.. code:: javascript</p>
<pre><code>initializeUnorderedBulkOp()     -&gt; Bulk   - Initialize an unordered bulk
initializeOrderedBulkOp()       -&gt; Bulk   - Initialize an ordered bulk
</code></pre>
<h2 id="operations-possible-on-bulk-instance"><a class="header" href="#operations-possible-on-bulk-instance">Operations Possible On Bulk Instance</a></h2>
<p>Available operations follow the fluent API for insert, update and
remove.</p>
<p>.. code:: javascript</p>
<pre><code>/**
 * Update one document matching the selector
 */
bulk.find({a : 1}).updateOne({$inc : { x : 1 }});

/**
 * Update all documents matching the selector
 */
bulk.find({a : 2}).update({$inc : { x : 2 }});

/**
 * Update all documents
 * Note that find() is prohibited; the query is required
 */
bulk.find({}).update({$inc : { x : 2 }});

/**
 * Replace entire document (update with whole doc replace)
 */
bulk.find({a : 3}).replaceOne({ x : 3 });

/**
 * Update one document matching the selector or upsert
 */
bulk.find({a : 1}).upsert().updateOne({$inc : { x : 1 }});

/**
 * Update all documents matching the selector or upsert
 */
bulk.find({a : 2}).upsert().update({$inc : { x : 2 }});

/**
 * Replaces a single document matching the selector or upsert
 */
bulk.find({a : 3}).upsert().replaceOne({ x : 3 });

/**
 * Remove a single document matching the selector
 */
bulk.find({a : 4}).removeOne();

/**
 * Remove all documents matching the selector
 */
bulk.find({a : 5}).remove();

/**
 * Remove all documents
 * Note that find() is prohibited; the query is required
 */
bulk.find({}).remove();

/**
 * Insert a document
 */
bulk.insert({ x : 4 });

/**
 * Execute the bulk operation, with an optional writeConcern
 * overwriting the default w:1. A descriptive error should be
 * raised if execute is called more than once or before any
 * operations have been added.
 */
writeConcern = { w: 1, wtimeout: 100 }
bulk.execute(writeConcern);
</code></pre>
<h1 id="current-shell-implementation"><a class="header" href="#current-shell-implementation">Current shell implementation</a></h1>
<p>The shell implementation serves as a guide only. One main difference between the shell implementation and a proper driver implementation
is that unordered bulk operations are not optimized by re-ordering the writes; only the execution semantics are kept correct.
You can find it here:</p>
<p>https://github.com/mongodb/mongo/blob/master/src/mongo/shell/bulk_api.js</p>
<p>If you need more information about the actual write command you can find the specification at the following location</p>
<p>https://github.com/mongodb/specifications/blob/master/source/server_write_commands.rst</p>
<h2 id="modes-of-execution"><a class="header" href="#modes-of-execution">Modes of Execution</a></h2>
<p>The write commands have a new option called <strong>ordered</strong> that is a boolean. <strong>ordered</strong> replaces <strong>continueOnError</strong> but with slightly different semantics.</p>
<h3 id="ordered--true"><a class="header" href="#ordered--true">ordered = true</a></h3>
<p>If the driver sets <strong>ordered = true</strong> all operations will be executed serially in the write command and the operation will abort on the first error. So given the 3 following operations.</p>
<p>.. code:: javascript</p>
<pre><code>bulk.insert({a:1})
bulk.insert({a:2})
bulk.find({a:2}).update({$set: {a:1}}) // Clashes with unique index
bulk.find({a:1}).remove()
</code></pre>
<p>With <strong>ordered = true</strong> the bulk operation will terminate after the update as it errors out. With <strong>ordered = true</strong> the driver will receive only a single error.</p>
<h3 id="ordered--false"><a class="header" href="#ordered--false">ordered = false</a></h3>
<p>If the driver sets <strong>ordered = false</strong> all operations might be applied in parallel by the server. The server will execute all the operations and return all errors created by the operations. So given the 4 following operations.</p>
<p>.. code:: javascript</p>
<pre><code>bulk.insert({a:1})
bulk.insert({a:2})
bulk.find({a:2}).update({$set: {a:1}}) // Might clash with unique index
bulk.find({a:3}).remove
bulk.find({a:2}.update({$set: {a:1}}) // Might clash with unique index
</code></pre>
<p>Due to the write operations potentially happening concurrently there is no way to determine the final state of the bulk operation above. If <strong>insert({a:1})</strong> happens before the two updates we will get 2 duplicate key index errors from the two update operations. If one of the updates happen first the insert will error out. By setting <strong>ordered</strong> to false we are trading off guaranteed order of execution for increased parallelization.</p>
<h2 id="ordered-bulk-operations"><a class="header" href="#ordered-bulk-operations">Ordered Bulk Operations</a></h2>
<p>To start the ordered bulk operation call.</p>
<p>.. code:: javascript</p>
<pre><code>initializeOrderedBulkOp() -&gt; bulk
</code></pre>
<p>The ordered bulk operation guarantees the order of writes for a mixed set of operations. This means the driver needs to ensure that all operations are performed in the order they were added.</p>
<p>Consider the following set of operations:</p>
<p>.. code:: javascript</p>
<pre><code>var bulk = db.c.initializeOrderedBulkOp()
bulk.insert({a : 1})
bulk.insert({a : 2})
bulk.insert({a : 3})
bulk.find({a : 2}).upsert().updateOne({$set : { a : 4 }});
bulk.find({a : 1}).removeOne();
bulk.insert({a : 5})
bulk.execute({w : 1})
</code></pre>
<p>This will generate the following sequence of writes to the server.</p>
<ol>
<li>Insert write command</li>
<li>Update write command</li>
<li>Remove write command</li>
<li>Insert write command</li>
</ol>
<p>One thing to note is that if a write command goes over the maximum number of documents or maxBSONMessageSize for an individual write command it needs to be split into multiple as for unordered bulks.</p>
<p>.. NOTE::
<strong>ContinueOnError</strong> Ordered operations are synonymous with
continueOnError = false. There is no way to specify a different
value for continueOnError.</p>
<h2 id="unordered-bulk-operations"><a class="header" href="#unordered-bulk-operations">Unordered Bulk Operations</a></h2>
<p>To start the unordered bulk operation call:</p>
<p>.. code:: javascript</p>
<pre><code>initializeUnorderedBulkOp() -&gt; bulk
</code></pre>
<p>The unordered bulk operation does not guarantee order of execution of any added write operations. If you have the following code.</p>
<p>.. code:: javascript</p>
<pre><code>var bulk = db.c.initializeUnorderedBulkOp()
bulk.insert({_id : 1})
bulk.find({_id : 2}).updateOne({$inc : { x : 1 }});
bulk.find({_id : 3}).removeOne();
bulk.insert({_id : 4})
bulk.find({_id : 5}).updateOne({$inc : { x : 1 }});
bulk.find({_id : 6}).removeOne();
bulk.execute({w:1})
</code></pre>
<p>Internally the driver will execute 3 write commands. One each for the inserts, updates and removes. It's important to note that the write commands could be executed in any order.</p>
<p>.. NOTE::
<strong>ContinueOnError</strong> Unordered operations are synonymous with
continueOnError = true. There is no way to specify a different
value for continueOnError.</p>
<h2 id="request-size-limits"><a class="header" href="#request-size-limits">Request Size Limits</a></h2>
<p>Supporting unlimited batch sizes poses two problems - the BSONObj internal size limit is 16 MiB + small overhead (for commands), and a small write operation may have a much larger response.  In order to ensure a batch can be correctly processed, two limits must be respected.</p>
<p>Both of these limits can be found using hello or legacy hello:</p>
<ul>
<li>
<p><code>maxBsonObjectSize</code> : currently 16 MiB, this is the maximum size of writes (excepting command overhead)
that should be sent to the server.  Documents to be inserted, query documents for updates and
deletes, and update expression documents must be &lt;= this size.</p>
<p>Batches containing more than one insert, update, or delete must be less than <code>maxBsonObjectSize</code>.
Note that this means a single-item batch can exceed <code>maxBsonObjectSize</code>.  The additional overhead of
the command itself is guaranteed not to trigger an error from the server, except in the case of
<code>SERVER-12305 &lt;https://jira.mongodb.org/browse/SERVER-12305&gt;</code>_.</p>
</li>
<li>
<p><code>maxWriteBatchSize</code> : currently 100,000 (as of MongoDB 3.6 via <code>SERVER-13061 &lt;https://jira.mongodb.org/browse/SERVER-13061&gt;</code>__), this is the maximum number of inserts, updates, or deletes that
can be included in a write batch.  If more than this number of writes are included, the server cannot
guarantee space in the response document to reply to the batch.</p>
</li>
</ul>
<p>If the batch is too large in size or bytes, the command may fail. The bulk API should ensure that this does not happen by splitting a batch into multiple batches of the same type if any of the limits are hit.</p>
<h2 id="on-bulk-execution"><a class="header" href="#on-bulk-execution">On Bulk Execution</a></h2>
<p>A descriptive error should be raised if <code>execute</code> is called more than once.</p>
<p>A descriptive error should be raise if <code>execute</code> is called before any operations have been added.</p>
<h2 id="possible-implementation"><a class="header" href="#possible-implementation">Possible Implementation</a></h2>
<p>One possible solution for serialization of bulk operations is to serialize some preamble and then to incrementally serialize and append each document to the collected message. The command wrapper has the array argument last so that the programmer can append to it. As you incrementally serialize, first check the collected size plus the incremental size.</p>
<p>If it is less than maxBsonObjectSize (incorporate additional headroom for your implementation), you can safely append and the message will be accepted by the server. If it exceeds maxBsonObjectSize, you should "finish" (without appending, updating the BSON array and document sizes) and execute the collected message. A new write command message will be serialized.</p>
<p>The un-appended incremental serialization from before will be appended on the new message. Continue incremental serialization, appending, and execution as above until the bulk operation is completed. Your implementation may need additional headroom for whatever is not already in the preamble, e.g., write concern, finish bytes, etc.</p>
<p>There are two maximum write command sizes a driver needs to take into account. The first one is <strong>maxBsonObjectSize</strong> that defines the maximum size of a single write command. The current tolerance is <strong>maxBsonObjectSize</strong> + 16K. If the driver sends a message that overflows this tolerance the server will respond with an error.</p>
<p>The second value is the <strong>maxWriteBatchSize</strong> value which specifies the maximum number of operations allowed in a single write command. In 2.6 this is currently set to <strong>1000</strong> operations. If the driver sends a write command with more than <strong>maxWriteBatchSize</strong> operations in it, the server will error out.</p>
<p>To avoid these errors the driver needs to split write commands if they overflow the two cases into one or more new write commands.</p>
<h1 id="on-errors"><a class="header" href="#on-errors">On Errors</a></h1>
<p>It's important to understand the way the processing of commands happens on the server to understand the possible error scenarios. Let's look at the processing pipeline.</p>
<p>Validate BSON/Auth -&gt; Write Operations -&gt; Apply Write Concern</p>
<p>The first step will abort the operation completely with no changes applied to Mongo. An error at this stage will be top level an will mean no attempt was made to process the command. This also uniquely sets <strong>ok</strong> to <strong>0</strong>.</p>
<p>.. code:: javascript</p>
<p>{
"ok" : 0,
"code" : 13,
"errmsg": "Authentication error"
}</p>
<p>If the first step passes with no errors there might be a command level error such as a duplicate key error. This is a write error and will return an error results containing the <strong>writeErrors</strong> field.</p>
<p>.. code:: javascript</p>
<p>{
"ok" : 1,
"n" : 0,
"writeErrors" : [
{
"index" : 0,
"code" : 11000,
"errmsg" : "DuplicateKey insertDocument :: caused by :: 11000 E11000 duplicate key error index: test.test.$a_1  dup key: { : 1 }"
}
],
}</p>
<p>In the case of an <strong>ordered</strong> bulk operation you'll only ever get a single write error as the execution of the command will stop at the first error. In an <strong>unordered</strong> bulk operation you might have more than one.</p>
<p>The last step of applying the write concern can also cause an error. Given a write concern <strong>{w:5, wtimeout:1000}</strong> where there is only 3 servers in the replicaset, the write concern can never be fulfilled and will return an error. An example server response might be:</p>
<p>.. code:: javascript</p>
<p>{
"ok" : 1,
"n" : 1,
"writeConcernError" : {
"code" : 64,
"errmsg" : "...."
}
}</p>
<p>Notice how write concern is just a single error for the whole command. Getting a writeConcernError does not mean the items were not applied, it means the write concern could not be fulfilled. In the example above <strong>n</strong> is still <strong>1</strong>.</p>
<p>It's fair to consider the server response field <strong>writeErrors</strong> to be hard errors while <strong>writeConcernError</strong> is a soft error.</p>
<h1 id="merging-results"><a class="header" href="#merging-results">Merging Results</a></h1>
<h2 id="handling-errors"><a class="header" href="#handling-errors">Handling errors</a></h2>
<p>Handling the merging of errors is most easily expressed with some examples.</p>
<p>Handling Write Errors</p>
<pre><code>
Consider the following following bulk write operation:

.. code:: javascript

  collection.ensureIndex({a:1}, {unique:true})
  var bulk = collection.initializeOrderedBulkOp()
  bulk.insert({a:1})
  bulk.insert({a:2})
  bulk.find({a:2}).upsert().update({$set:{a:1}})
  bulk.insert({a:3})
  bulk.execute()

This operation will only execute the three first operations (the first two inserts and an upsert)
before stopping due to a duplicate key error. The merged result would look something like this:

.. code:: javascript

  {
    "nInserted" : 2,
    "nUpserted" : 0,
    "nMatched" : 0,
    "nModified" : 0,
    "nRemoved" : 1,
    "upserted" : [ ]
    "writeErrors" : [
      {
        "index" : 2,
        "code" : 11000,
        "errmsg" : "DuplicateKey insertDocument :: caused by :: 11000 E11000 duplicate key error index: test.test.$a_1  dup key: { : 1 }"
      }
    ]
    "writeConcernErrors": []
  }

In this situation the client should throw a single error and stop processing.

Handling Write Concern Errors
</code></pre>
<p>Write concern is applied after the server side execution of the write operations.</p>
<p>This means that replication failure or other forms of writeConcernErrors should not affect the execution of the batch
but simply serve as an indication that the write concern has not been met.</p>
<p>If there is no write concern error the bulk result's "writeConcernErrors" array is empty.</p>
<p>When the bulk operation is implemented using legacy opcodes, no server error
code is available. The server's getlasterror response is like:</p>
<p>.. code:: javascript</p>
<p>{
"ok" : 1,
"wtimeout": true,
"err": "timeout"
}</p>
<p>In this case the driver must construct a writeConcernErrors array containing one error document with code 64,
and the "err" field from the getlasterror response as the errmsg.</p>
<p>An example with "w: 5" and fewer than 5 replicas:</p>
<p>.. code:: javascript</p>
<p>var bulk = collection.initializeOrderedBulkOp()
bulk.insert({a:1})
bulk.execute({w:5, wtimeout:1})</p>
<p>The expected result from these operations are.</p>
<p>.. code:: javascript</p>
<p>{
"nInserted" : 1,
"nUpserted" : 0,
"nMatched" : 0,
"nModified" : 0,
"nRemoved" : 0,
"upserted" : [ ]
"writeErrors" : [ ],
"writeConcernErrors": [{
"code": 64,
"waiting for replication timed out",
}]
}</p>
<p>.. note:: The example output is from MongoDB 2.6. In MongoDB 2.4 the driver supplies the error code 64, and the error message is "timeout". Starting in MongoDB 3.0, the writeConcernError code is 100 and the message is "Not enough data-bearing nodes".</p>
<h2 id="general-rule-of-handling-errors"><a class="header" href="#general-rule-of-handling-errors">General rule of handling errors</a></h2>
<ol>
<li>A top level error means the whole command failed and should cause a command failure error.</li>
<li>For unordered bulk operations all write Errors should be rewritten and merged together.</li>
<li>For ordered bulk operations the returned write Error should be rewritten and returned.</li>
<li>Write Concern errors should not halt the processing of <strong>ordered</strong> bulk operations.</li>
</ol>
<h2 id="merging-write-errors"><a class="header" href="#merging-write-errors">Merging write errors</a></h2>
<p>A bulk operation might involve multiple write commands.  Each write command could potentially return write errors and/or a write concern error. Each error in the <strong>writeErrors</strong> array contains an index pointing to the original document position in the write command document that caused it.</p>
<p>Consider the following bulk operation</p>
<p>.. code:: javascript</p>
<pre><code>collection.ensureIndex({a:1}, {unique:true})
var bulk = db.c.initializeOrderedBulkOp()
bulk.insert({a:1})
bulk.insert({a:2})
bulk.find({a:2}).updateOne({$set : { a : 1 }});
bulk.find({a:4}).removeOne();
bulk.execute({w:1})
</code></pre>
<p>The operation</p>
<p>.. code:: javascript</p>
<pre><code>bulk.find({a:2}).updateOne({$set : { a : 1 }});
</code></pre>
<p>causes an error</p>
<p>.. code:: javascript</p>
<p>{
"ok" : 1,
"nModified" : 0,
"n" : 0,
"writeErrors" : [
{
"index" : 0,
"code" : 11000,
"errmsg" : "DuplicateKey insertDocument :: caused by :: 11000 E11000 duplicate key error index: test.test.$a_1  dup key: { : 1 }"
}
]
}</p>
<p>In the returned result, the <strong>index</strong> variable of the error points to document <strong>0</strong> from the update where it failed during execution. However in the original chain of operations the <strong>update</strong> operation is the third (<strong>index 2</strong>). To correctly correlate the errors to the user-provided order we need to rewrite the error to point to the correct index so the user can identify what document caused the error. So in this the error aspect of the final result will look like.</p>
<p>.. code:: javascript</p>
<p>{
"ok" : 1,
"nModified" : 0,
"n" : 2,
"writeErrors" : [
{
"index" : 2,
"code" : 11000,
"errmsg" : "DuplicateKey insertDocument :: caused by :: 11000 E11000 duplicate key error index: test.test.$a_1  dup key: { : 1 }"
}
]
}</p>
<p>Notice the <strong>index: 2</strong> correctly pointing to the original document.</p>
<p>To correctly handle the merging the driver needs to keep track of the original indexes and how they map to the errors returned by the write commands. There might be a need to keep an index in memory to be able to correctly handle the mapping.</p>
<h2 id="write-concern-errors"><a class="header" href="#write-concern-errors">Write concern errors</a></h2>
<p>Each writeConcernError document received from a server operation (either a write command or legacy write) is appended to the bulk result's "writeConcernErrors" array:</p>
<p>.. code:: javascript</p>
<pre><code>var bulk = db.c.initializeOrderedBulkOp()
bulk.insert({a:1})
bulk.insert({a:2})
bulk.find({a:1}).remove()
bulk.execute({w:5, wtimeout:100})
</code></pre>
<p>The outcome on MongoDB 2.6 with fewer than 5 replicas is similar to:</p>
<p>.. code:: javascript</p>
<p>{
"nInserted" : 2,
"nUpserted" : 0,
"nMatched" : 0,
"nModified" : 0,
"nRemoved" : 1,
"upserted" : [ ]
"writeErrors" : [ ],
"writeConcernErrors": [{
"code": 64,
"waiting for replication timed out",
}, {
"code": 64,
"waiting for replication timed out",
}]
}</p>
<p>If there is no write concern error the bulk result's "writeConcernErrors" array is empty.</p>
<p>.. note:: Previous versions of this spec were ambiguous about reporting writeConcernErrors. Some clients include a singular field "writeConcernError" in bulk results; the singular form is now deprecated and an array called "writeConcernErrors" is required.</p>
<h2 id="handling-upserts"><a class="header" href="#handling-upserts">Handling upserts</a></h2>
<p>When performing updates with upsert true the write command might return an upserted field. If it's a single document update command that causes an upsert it will look like.</p>
<p>.. code:: javascript</p>
<pre><code>{
    ok: 1
  , nModified: 0
  , n: 1      
  , upserted: {index:0, _id:ObjectId(".....")}
}
</code></pre>
<p>On the other hand if we are upserting a series of documents the <strong>upserted</strong>  field will contain an array of the results. Given an update command that causes 2 upserts the result will look like.</p>
<p>.. code:: javascript</p>
<pre><code>{
    ok: 1
  , nModified: 0
  , n: 2
  , upserted: [
      {index:0, _id:ObjectId(".....")}
    , {index:1, _id:ObjectId(".....")}
  ]
}
</code></pre>
<p>As in the case of errors the driver needs to rewrite the indexes for the upserted values to merge the results together into the final result so they reflect the initial order of the updates in the user specified batch.</p>
<h1 id="reporting-errors"><a class="header" href="#reporting-errors">Reporting Errors</a></h1>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>Depending on the language and platform there are different semantics on how to raise errors. For languages that usually raise exceptions it's recommended that an exception be raised when an ordered bulk operation fails.</p>
<p>Given the following scenario</p>
<p>.. code:: javascript</p>
<p>collection.ensureIndex({a:1}, {unique:true})
var bulk = collection.initializeOrderedBulkOp()
bulk.insert({a:1})
bulk.insert({a:1})
bulk.execute({w:5, wtimeout:1})</p>
<p>In languages where the rule is to report errors by throwing an exception the duplicate insert should cause an exception to be raised when execute is called.</p>
<p>In the case of an unordered bulk operation the exception should be raised after the bulk has finished executing. It's important to differentiate between a <strong>write</strong> error and <strong>write concern</strong> error if exceptions are used to differentiate between the <strong>hard</strong> error of a write error and the <strong>soft</strong> error caused by a write concern error.</p>
<h2 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h2>
<p>Callback based languages or platform should return a results object containing the aggregated state of the bulk operations. Some platforms like Node.js supports callbacks with the format <strong>function(err, object)</strong>. In this case the result object should be returned as the err field if it contains any errors, only returning in the object field if no write or write concern errors happened.</p>
<h1 id="results-object"><a class="header" href="#results-object">Results Object</a></h1>
<p>The shell and <strong>Node.js</strong> implements the result as a custom object wrapping the results. This is to simplify the access to the internal state of the merged results. It serves mostly as an example as different languages might implement the results differently depending on their chosen error mechanism. F.ex it might make sense to throw an exception if the command fails at the authentication stage versus a duplicate key error on one of the operations in a bulk operation.</p>
<p>It keeps track of several aggregated values</p>
<p>========= =============================================================
field     description
========= =============================================================
nInserted Number of inserted documents
nUpserted Number of upserted documents
nMatched  Number of documents matched for update
nModified Number of documents actually changed by update
nRemoved  Number of documents removed
========= =============================================================</p>
<p>nMatched is equivalent to the "n" field in the getLastError response after a legacy update. nModified is quite different from "n". nModified is incremented only when an update operation actually changes a document.</p>
<p>For example, if a document has <code>x: 1</code> and we update it with <code>{$set: {x: 1}}</code>, nModified is not incremented for that document.</p>
<p>The WriteError's are wrapped in their own wrapper that also contains the operation that caused the error to happen. Similarly the WriteConcernError is a simple wrapper around the result to ensure it's read only.</p>
<p>A client may optionally provide a method to merge writeConcernErrors into one, analogous to how mongos does.</p>
<p>.. code:: javascript</p>
<p>var WRITE_CONCERN_ERROR = 64;</p>
<p>/**</p>
<ul>
<li>Wraps the error
*/
var WriteError = function(err) {
if(!(this instanceof WriteError)) return new WriteError(err);</li>
</ul>
<pre><code>// Define properties
defineReadOnlyProperty(this, "code", err.code);
defineReadOnlyProperty(this, "index", err.index);
defineReadOnlyProperty(this, "errmsg", err.errmsg);

//
// Define access methods
this.getOperation = function() {
  return err.op;
}
</code></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Wraps a write concern error
*/
var WriteConcernError = function(err) {
if(!(this instanceof WriteConcernError)) return new WriteConcernError(err);</li>
</ul>
<pre><code>// Define properties
defineReadOnlyProperty(this, "code", err.code);
defineReadOnlyProperty(this, "errmsg", err.errmsg);
</code></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Wraps the result for the commands
*/
var BulkWriteResult = function(bulkResult) {
// Define properties
defineReadOnlyProperty(this, "ok", bulkResult.ok);
defineReadOnlyProperty(this, "nInserted", bulkResult.nInserted);
defineReadOnlyProperty(this, "nUpserted", bulkResult.nUpserted);
defineReadOnlyProperty(this, "nMatched", bulkResult.nMatched);
defineReadOnlyProperty(this, "nModified", bulkResult.nModified);
defineReadOnlyProperty(this, "nRemoved", bulkResult.nRemoved);</li>
</ul>
<pre><code>//
// Define access methods
this.getUpsertedIds = function() {
  return bulkResult.upserted;
}

this.getUpsertedIdAt = function(index) {
  return bulkResult.upserted[index];
}

this.getRawResponse = function() {
  return bulkResult;
}

this.hasWriteErrors = function() {
  return bulkResult.writeErrors.length &gt; 0;
}

this.getWriteErrorCount = function() {
  return bulkResult.writeErrors.length;
}

this.getWriteErrorAt = function(index) {
  if(index &lt; bulkResult.writeErrors.length) {
    return bulkResult.writeErrors[index];
  }
  return null;
}

this.hasWriteConcernError = function() {
  return bulkResult.writeConcernErrors.length &gt; 0;
}

//
// Determine if we have any errors
this.hasErrors = function() {
  return this.hasWriteErrors() || this.hasWriteConcernError();
}

//
// Get all errors
this.getWriteErrors = function() {
  return bulkResult.writeErrors;
}

this.getWriteConcernError = function() {
  if(bulkResult.writeConcernErrors.length == 0) {
    return null;
  } else if(bulkResult.writeConcernErrors.length == 1) {
    // Return the error
    bulkResult.writeConcernErrors[0];
  } else {

    // Combine the errors
    var errmsg = "";
    for(var i = 0; i &lt; bulkResult.writeConcernErrors.length; i++) {
      var err = bulkResult.writeConcernErrors[i];
      if (i != 0) {
        errmsg = errmsg + " and ";
      }

      errmsg = errmsg + '"' + err.errmsg + '"';
    }

    return new WriteConcernError({ errmsg : errmsg, code : WRITE_CONCERN_ERROR });
  }
}

this.isOK = function() {
  return bulkResult.ok == 1;
}
</code></pre>
<p>}</p>
<h1 id="pre-26-support"><a class="header" href="#pre-26-support">Pre 2.6 Support</a></h1>
<p>The batch API is required to work with pre <strong>2.6</strong>. This means detecting in the driver if the server supports the new write commands and downgrading to existing <strong>OP_INSERT/OP_UPDATE/OP_REMOVE</strong> if it does not.</p>
<p>Legacy servers don't report nModified for updates, and it is impossible for the driver to simulate it: nModified must be equal to the number of documents that are actually different after an update, but legacy servers only report the number of documents matched. The driver must therefore set the result's nModified field to null, or omit the field, when it executes a bulk operation against a legacy server. In static languages where nModified is an integer-type property on bulk results, an exception must be thrown if a user accesses the nModified property after executing a bulk operation on a legacy server.</p>
<p>One important aspect to keep in mind is that the existing <strong>bulk</strong> insert operation cannot be used as you need to retrieve the <strong>getLastError</strong> results for each individual operation. Thus the driver must execute inserts one by one.</p>
<p>Another important aspect to keep in mind is that a replication error can be signaled several ways by the <strong>getLastError</strong> result. The following error codes for the field code are an indicator of a replication error.</p>
<p>========= =============================================================
Code      Description
========= =============================================================
50        Operation exceeded time limit.
13475     Operation exceeded time limit.
16986     Operation exceeded time limit.
16712     Operation exceeded time limit.
========= =============================================================</p>
<p>Thee are also some some errors only detectable by inspecting the <strong>errmsg</strong> field.</p>
<p>====================  =============================================================
ErrMsg                Description
====================  =============================================================
exceeded time limit   Operation exceeded time limit.
execution terminated  Operation exceeded time limit.
====================  =============================================================</p>
<p>If an error does not return a code the driver can set the returned value to <strong>8</strong> (unknown error).  A BSON serializing error should be marked with <strong>22</strong> (illegal BSON).</p>
<p>There are some codes that don't match up between the <strong>2.6</strong> and existing servers. The suggestion is to not attempt to rewrite these errors as it will make the code very brittle. Some slight differences in error codes
and error messages between the write commands and the legacy operations are acceptable.</p>
<h2 id="nmodified"><a class="header" href="#nmodified">nModified</a></h2>
<p>The 2.6 server includes "nModified" in its response to an "update" command. The server increments nModified only when an "update" command has actually changed a document.
For example, if a document already has <code>x: 1</code> and you update it with <code>{$set: {x: 1}}</code>,
nModified is not incremented.
nModified is impossible to simulate with OP_UPDATE, which returns only "n",
the number of matched documents.</p>
<p><strong>Legacy writes</strong>: The result of a bulk operation that uses legacy opcodes must set
nModified to NULL, or omit the field.
If your language is constrained such that you must include the field,
then user code should get an exception when accessing the field if you're talking to a legacy server.</p>
<p><strong>Mixed-version sharded cluster</strong>:
When a client executes an "update" command on a 2.6 mongos,
and mongos executes it against some 2.4 mongods,
mongos omits nModified from the response, or sets nModified to NULL.
(We don't yet know which: <code>SERVER-13001</code>_)
If the client does a series of "update" commands within the same bulk operation against the same mongos,
some responses could include nModified and some won't,
depending on which mongods the mongos sent the operation to.
The driver algorithm for merging results, when using write commands, in pseudocode:</p>
<p>.. code:: javascript</p>
<pre><code>full_result = {
    "writeErrors": [],
    "writeConcernErrors": [],
    "nInserted": 0,
    "nUpserted": 0,
    "nMatched": 0,
    "nModified": 0,
    "nRemoved": 0,
    "upserted": [],
}
</code></pre>
<p>::</p>
<pre><code>for each server response in all bulk operations' responses:
    if the operation is an update:
        if the response has a non-NULL nModified:
            if full_result has a non-NULL nModified:
                full_result['nModified'] += response['nModified']
        else:
            # If any call does not return nModified we can't report
            # a valid final count so omit the field completely.
            remove nModified from full_result, or set to NULL
</code></pre>
<p>.. _SERVER-13001: https://jira.mongodb.org/browse/SERVER-13001</p>
<h1 id="questions--answers"><a class="header" href="#questions--answers">Questions &amp; Answers</a></h1>
<p><strong>Question:</strong> I'm writing my own driver should I support legacy downgrading.
<strong>Answer:</strong> Legacy downgrading is explained to help people support pre 2.6 servers but is not mandated for anything but the official drivers.</p>
<p><strong>Answer:</strong> Changes where made to GLE in 2.6 that makes the error reporting more consistent. Downgrading will only correctly work against 2.4.X or earlier.</p>
<p><strong>Question:</strong> My downgrading code breaks with 2.6</p>
<p><strong>Answer:</strong> Changes where made to GLE in 2.6 that makes the error reporting more consistent. Downgrading will only correctly work against 2.4.X or earlier.</p>
<p><strong>Question:</strong> Will there be any way for a user to set the number of wire operations a bulk operation will take (for debugging purposes).</p>
<p><strong>Answer:</strong> No.</p>
<p><strong>Question:</strong> Will there be support for .explain() with the bulk
interface?</p>
<p><strong>Answer:</strong> Not for 2.6. It may be added with a later release along with
server support for mixed operations in a single bulk command</p>
<p><strong>Question:</strong> The definition for unordered introduces indeterminism to the operation.
For example, what is the state of the collection after:</p>
<p>.. code:: javascript</p>
<pre><code>var bulk = db.c.initializeBulkOp()
bulk.insert({_id : 1, x : 1})
bulk.find({_id : 1}).updateOne({$inc : { x : 1 }});
bulk.find({_id : 1}).removeOne();
bulk.execute({w:1})
</code></pre>
<p>You could end up with either {_id : 1, x : 1}, {_id : 1, x : 2}, or no document at all,
depending on the order that the operations are performed in.</p>
<p><strong>Answer:</strong> This is by design and definition. If the order matters then don't use an unordered bulk operation. No order will be defined or respected in an unordered operation.</p>
<p><strong>Question:</strong> What should the driver do when an <strong>ordered</strong> bulk command is split into multiple write commands and an error happens?</p>
<p><strong>Answer:</strong> If it's an <strong>ordered</strong> bulk command that is split into multiple write commands the driver should not send any remaining write commands after encountering the first error.</p>
<p><strong>Question:</strong> What should the driver do when an <strong>unordered</strong> bulk command is split into multiple write commands and an error happens?</p>
<p><strong>Answer:</strong> It's important to note that if the command is an <strong>unordered</strong> bulk command and it's split into multiple write command it should continue processing all the write commands even if there are errors.</p>
<p><strong>Question:</strong> Does the driver need to merge errors from split write commands?</p>
<p><strong>Answer:</strong> Yes</p>
<p><strong>Question:</strong> Is find() with no argument allowed?</p>
<p><strong>Answer:</strong> No, a selector is required for find() in the Bulk API.</p>
<p><strong>Question:</strong> Is find({}) with an empty selector allowed?</p>
<p><strong>Answer:</strong> Yes, updating or removing all documents using find({}) is allowed.</p>
<p><strong>Question:</strong> My unordered bulk operation got split into multiple batches that all reported a write concern error. Should I report all of the write concern errors ?</p>
<p><strong>Answer:</strong> Yes, combined into an array called "writeConcernErrors".</p>
<h1 id="detailed-test-cases"><a class="header" href="#detailed-test-cases">Detailed Test Cases</a></h1>
<p>These Test cases in this section serve the purpose of helping you validate the correctness of your <strong>Bulk API</strong> implementation.</p>
<h2 id="insert"><a class="header" href="#insert">INSERT</a></h2>
<p>Test Case 1:
Dynamic languages: raise error if wrong arg type
initializeUnorderedBulkOp().insert('foo') throws a reasonable error</p>
<pre><code>    initializeUnorderedBulkOp().insert([{}, {}]) throws a reasonable error: we cant do a bulk insert with an array
    
    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
Insert not allowed with find({}):
initializeUnorderedBulkOp().find({}).insert({}) is a type error.</p>
<pre><code>    Same for initializeOrderedBulkOp().    
</code></pre>
<p>Test Case 3: <em>Removed</em></p>
<p>Test Case 4:
Inserting a document succeeds and returns 'nInserted of 1:
Empty collection.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.insert({_id: 1})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 1,
            "nUpserted" : 0,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

    Collection contains only {_id: 1}.
    
    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 5:
The driver generates _id client-side for inserted documents:
Empty collection.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.insert({})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 1,
            "nUpserted" : 0,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

        _id = collection.findOne()._id
        // pid = bytes 7 and 8 (counting from zero) of _id, as big-endian unsigned short
        pid == my PID

    Alternatively, just watch the server log or mongosniff and manually verify the _id was sent to the server.

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 6:
Insert doesnt accept an array of documents:
initializeUnorderedBulkOp().insert([{}, {}]) throws</p>
<pre><code>    Same for initializeOrderedBulkOp().  
</code></pre>
<h2 id="find"><a class="header" href="#find">FIND</a></h2>
<p>Test Case 1:
Dynamic languages: find() with no args is prohibited:
.. code:: javascript</p>
<pre><code>        batch = initializeUnorderedBulkOp()
        batch.find() raises error immediately

    Same for initializeOrderedBulkOp().
</code></pre>
<h2 id="update"><a class="header" href="#update">UPDATE</a></h2>
<p>Test Case 1:
Dynamic languages: raise error if wrong arg type
.. code:: javascript</p>
<pre><code>        initializeUnorderedBulkOp().find({}).update('foo') throws a reasonable error

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
Dynamic languages: Update requires find() first:
.. code:: javascript</p>
<pre><code>        initializeUnorderedBulkOp().update({$set: {x: 1}}) is a type error

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 3:
Key validation, all top-level keys must be $-operators:
These throw errors, even without calling execute():</p>
<pre><code>    .. code:: javascript

        initializeUnorderedBulkOp().find({}).update({key: 1})
        initializeUnorderedBulkOp().find({}).update({key: 1, $key: 1})

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 4:
update() updates all matching documents, and reports nMatched correctly:
Collection has {key: 1}, {key: 2}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({}).update({$set: {x: 3}})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 2,
            "nModified" : 2,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.
    
    Collection has:
        .. code:: javascript

            {key: 1, x: 3}
            {key: 2, x: 3}

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 5:
update() only affects documents that match the preceding find():
Collection has {key: 1}, {key: 2}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).update({$set: {x: 1}})
        batch.find({key: 2}).update({$set: {x: 2}})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 2,
            "nModified" : 2,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.

    Collection has:
        .. code:: javascript

            {key: 1, x: 1}
            {key: 2, x: 2}
</code></pre>
<h2 id="update_one"><a class="header" href="#update_one">UPDATE_ONE</a></h2>
<p>Test Case 1:
Dynamic languages: raise error if wrong arg type
initializeUnorderedBulkOp().find({}).updateOne('foo') throws a reasonable error</p>
<pre><code>    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
Dynamic languages: Update requires find() first:
initializeUnorderedBulkOp().updateOne({$set: {x: 1}}) is a type error</p>
<pre><code>    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 3:
Key validation:
These throw errors; all top-level keys must be $-operators:</p>
<pre><code>    .. code:: javascript

        initializeUnorderedBulkOp().find({}).updateOne({key: 1})
        initializeUnorderedBulkOp().find({}).updateOne({key: 1, $key: 1})

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 4:
Basic:
Collection has {key: 1}, {key: 2}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({}).updateOne({}, {$set: {key: 3}})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 1,
            "nModified" : 1,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.

    .. code:: javascript

        collection.find({key: 3}).count() == 1.

    Same for initializeOrderedBulkOp().
</code></pre>
<h2 id="replace"><a class="header" href="#replace">REPLACE</a></h2>
<p>Test Case 1:
Dynamic languages: There is no replace.
initializeUnorderedBulkOp().find({}).replace() is a type error</p>
<pre><code>    Same for initializeOrderedBulkOp().
</code></pre>
<h2 id="replace_one"><a class="header" href="#replace_one">REPLACE_ONE</a></h2>
<p>Test Case 1:
Dynamic languages: raise error if wrong arg type
initializeUnorderedBulkOp().find({}).replaceOne('foo') throws a reasonable error</p>
<pre><code>    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
Dynamic languages: replaceOne requires find() first:
initializeUnorderedBulkOp().replaceOne({key: 1}) is a type error</p>
<pre><code>    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 3:
Key validation:
These throw errors; no top-level keys can be $-operators:</p>
<pre><code>    .. code:: javascript

        initializeUnorderedBulkOp().find({}).replaceOne({$key: 1})
        initializeUnorderedBulkOp().find({}).replaceOne({$key: 1, key: 1})

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 4:
If find() matches multiple documents, replaceOne() replaces exactly one of them:
Collection has {key: 1}, {key: 1}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).replaceOne({key: 3})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 1,
            "nModified" : 1,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.

    .. code:: javascript

        collection.distinct('key') == [1, 3].

    Same for initializeOrderedBulkOp().
</code></pre>
<h2 id="upsert-update"><a class="header" href="#upsert-update">UPSERT-UPDATE</a></h2>
<p>Test Case 1:
upsert() requires find() first:
initializeOrderedBulkOp().upsert() is a type error</p>
<pre><code>    upsert().update() upserts a document, and doesnt affect non-upsert updates in the same bulk operation. 'nUpserted is set:

    Empty collection.

    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).update({$set: {x: 1}})  // not an upsert
        batch.find({key: 2}).upsert().update({$set: {x: 2}})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 1,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 0,
            "upserted" : [{ "index" : 1, "_id" : ObjectId(...)}]
        }

    nModified is NULL or omitted if legacy server.
    
    collection has only {_id: ObjectId(...), key: 2, x: 2}.

    Repeat the whole batch. Now nMatched == 1, nUpserted == 0.

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
upsert().update() updates all matching documents:
Collection starts with {key: 1}, {key: 1}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).upsert().update({$set: {x: 1}})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 2,
            "nModified" : 2,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.
    
    collection has only {key: 1, x: 1}, {key: 1, x: 1}.

    Same for initializeOrderedBulkOp().

    We can upsert() a 16 MiB documentthe driver can make a command document slightly larger than the max document size.

    Empty collection.
    
    .. code:: javascript

        var bigstring = "string of length 16 MiB - 30 bytes"
        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).upsert().update({$set: {x: bigstring}})
        batch.execute() succeeds.

    Same for initializeOrderedBulkOp().
</code></pre>
<h2 id="upsert-update_one"><a class="header" href="#upsert-update_one">UPSERT-UPDATE_ONE</a></h2>
<p>Test Case 1:
upsert().updateOne() upserts a document, and doesnt affect non-upsert updateOnes in the same bulk operation. 'nUpserted is set:
Empty collection.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).updateOne({$set: {x: 1}})  // not an upsert
        batch.find({key: 2}).upsert().updateOne({$set: {x: 2}})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 1,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 0,
            "upserted" : [{ "index" : 1, "_id" : ObjectId(...)} ]
        }

    nModified is NULL or omitted if legacy server.

    collection contains only {key: 2, x: 2}.

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
upsert().updateOne() only updates one matching document:
Collection starts with {key: 1}, {key: 1}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).upsert().updateOne({$set: {x: 1}})
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 1,
            "nModified" : 1,
            "nRemoved" : 0,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.

    collection has only {key: 1, x: 1}, {key: 1}.
</code></pre>
<h2 id="upsert-replace_one"><a class="header" href="#upsert-replace_one">UPSERT-REPLACE_ONE</a></h2>
<p>Test Case 1:
upsert().replaceOne() upserts a document, and doesnt affect non-upsert replaceOnes in the same bulk operation. 'nUpserted is set:
Empty collection.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).replaceOne({x: 1})  // not an upsert
        batch.find({key: 2}).upsert().replaceOne({x: 2})

        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 1,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 0,
            "upserted" : [{ "index" : 1, "_id" : ObjectId(...)}  ]
        }

    nModified is NULL or omitted if legacy server.
    
    collection contains {x: 2}.

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
upsert().replaceOne() only replaces one matching document:
Collection starts with {key: 1}, {key: 1}.</p>
<pre><code>    .. code:: javascript

      batch = initializeUnorderedBulkOp()
      batch.find({key: 1}).upsert().replaceOne({x: 1})
      batch.execute() == {
          "writeErrors" : [ ],
          "writeConcernErrors" : [ ],
          "nInserted" : 0,
          "nUpserted" : 0,
          "nMatched" : 1,
          "nModified" : 1,
          "nRemoved" : 0,
          "upserted" : []
      }

    nModified is NULL or omitted if legacy server.

    collection has only {x: 1}, {key: 1}.
</code></pre>
<h2 id="remove"><a class="header" href="#remove">REMOVE</a></h2>
<p>Test Case 1:
remove() requires find() first:
initializeUnorderedBulkOp().remove() is a type error</p>
<pre><code>    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 1:
Remove() with empty selector removes all documents:
Collection starts with {key: 1}, {key: 1}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({}).remove()
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 2,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.

    Collection is now empty.

    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
Remove() with empty selector removes only matching documents:
Collection starts with {key: 1}, {key: 2}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({key: 1}).remove()
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 1,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.

    Collection contains only {key: 2}.

    Same for initializeOrderedBulkOp().
</code></pre>
<h2 id="remove_one"><a class="header" href="#remove_one">REMOVE_ONE</a></h2>
<p>Test Case 1:
removeOne() requires find() first:
initializeUnorderedBulkOp().removeOne() is a type error</p>
<pre><code>    Same for initializeOrderedBulkOp().
</code></pre>
<p>Test Case 2:
If several documents match find(), removeOne() removes one:
Collection has {key: 1}, {key: 1}.</p>
<pre><code>    .. code:: javascript

        batch = initializeUnorderedBulkOp()
        batch.find({}).removeOne()
        batch.execute() == {
            "writeErrors" : [ ],
            "writeConcernErrors" : [ ],
            "nInserted" : 0,
            "nUpserted" : 0,
            "nMatched" : 0,
            "nModified" : 0,
            "nRemoved" : 1,
            "upserted" : [ ]
        }

    nModified is NULL or omitted if legacy server.

    collection.count() == 1.

    Same for initializeOrderedBulkOp().
</code></pre>
<h2 id="mixed-operations-unordered"><a class="header" href="#mixed-operations-unordered">MIXED OPERATIONS, UNORDERED</a></h2>
<p>nMatched, nModified, nUpserted, nInserted, nRemoved are properly counted with an unordered bulk operation. The list of upserted documents is returned, with upserts indexes correctly rewritten.
Collection contains {a: 1}, {a: 2}.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeUnorderedBulkOp()
batch.find({a: 1}).update({$set: {b: 1}})
batch.find({a: 2}).remove()
batch.insert({a: 3})
batch.find({a: 4}).upsert().updateOne({$set: {b: 4}})
result = batch.execute()

result['nMatched'] == 1
result['nModified'] == 1 // (nModified is NULL or omitted if legacy server.)
result['nUpserted'] == 1
result['nInserted'] == 1
result['nRemoved'] == 1

result['upserted'].length == 1 and result['upserted'][0]['index'] == 3.
result['upserted'][0]['_id'] is an ObjectId.
</code></pre>
<h2 id="mixed-operations-ordered"><a class="header" href="#mixed-operations-ordered">MIXED OPERATIONS, ORDERED</a></h2>
<p>nMatched, nModified, nUpserted, nInserted, nRemoved are properly counted with an unordered bulk operation. The list of upserted documents is returned, with upserts indexes correctly rewritten.</p>
<p>Empty collection.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.insert({a: 1})
batch.find({a: 1}).updateOne({$set: {b: 1}})
batch.find({a: 2}).upsert().updateOne({$set: {b: 2}})
batch.insert({a: 3})
batch.find({a: 3}).remove()
result = batch.execute()

result['nInserted'] == 2
result['nUpserted'] == 1
result['nMatched'] == 1
result['nModified'] == 1 (nModified is NULL or omitted if legacy server.)
result['nRemoved'] == 1

result['upserted'].length == 1 and result['upserted'][0]['index'] == 2.
result['upserted'][0]['_id'] is an ObjectId.
</code></pre>
<h2 id="mixed-operations-auth"><a class="header" href="#mixed-operations-auth">MIXED OPERATIONS, AUTH</a></h2>
<p>Verify that auth failures are handled gracefully, especially in conjunction with other errors, such as write concern or normal write errors.</p>
<p>Example: Using user defined roles (UDR) create a user who can do insert but not remove and run an ordered batch performing both of these operations.</p>
<p>An ordered batch is expected to stop executing when the error is encountered, then raise the appropriate authentication error. If there have been write concern errors they may be lost. The behavior of an unordered batch is unspecified in the face of auth failure.</p>
<h2 id="unordered-batch-with-errors"><a class="header" href="#unordered-batch-with-errors">UNORDERED BATCH WITH ERRORS</a></h2>
<p>nMatched, nModified, nUpserted, nInserted, nRemoved are properly counted with an unordered bulk operation that includes a write error. The list of upserted documents is returned, with upserts indexes correctly rewritten.</p>
<p>Empty collection, unique index on 'a.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeUnorderedBulkOp()
batch.insert({b: 1, a: 1})
// one or two of these upserts fails:
batch.find({b: 2}).upsert().updateOne({$set: {a: 1}})
batch.find({b: 3}).upsert().updateOne({$set: {a: 2}})
batch.find({b: 2}).upsert().updateOne({$set: {a: 1}})
batch.insert({b: 4, a: 3})
// this and / or the first insert fails:
batch.insert({b: 5, a: 1})

batch.execute() should raise an error with some details:
error_details['nInserted'] == 2
error_details['nUpserted'] == 1
nMatched, nModified, nRemoved are 0.
(nModified is NULL or omitted if legacy server.)

error_details['upserted'].length == 1
error_details['upserted'][0]['index'] == 2
error_details['upserted'][0]['_id'] is an ObjectId
error_details['writeErrors'].length == 3
collection.distinct('a') == [1, 2, 3]
</code></pre>
<h2 id="ordered-batch-with-errors"><a class="header" href="#ordered-batch-with-errors">ORDERED BATCH WITH ERRORS</a></h2>
<p>nMatched, nModified, nUpserted, nInserted, nRemoved are properly counted with an ordered bulk operation that includes a write error. The list of upserted documents is returned, with upserts indexes correctly rewritten.</p>
<p>Empty collection, unique index on 'a.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.insert({b: 1, a: 1})
batch.find({b: 2}).upsert().updateOne({$set: {a: 1}})
batch.find({b: 3}).upsert().updateOne({$set: {a: 2}})
batch.find({b: 2}).upsert().updateOne({$set: {a: 1}})  // will fail
batch.insert({b: 4, a: 3})
batch.insert({b: 5, a: 1})

batch.execute() should raise an error with some details:
nUpserted, nMatched, nModified, nRemoved are 0
error_details['nInserted'] == 1
error_details['writeErrors'].length == 1
error = error_details['writeErrors'][0]
error['code'] == 11000
error['errmsg'] is a string.
error['index'] == 1
error['op'] == {q: {b: 2}, u: {$set: {a: 1}}, upsert: true}
collection.count() == 1  // subsequent inserts werent attempted
</code></pre>
<h2 id="batch-splitting-maxbsonobjectsize"><a class="header" href="#batch-splitting-maxbsonobjectsize">BATCH SPLITTING: maxBsonObjectSize</a></h2>
<p>More than 16 MiB worth of inserts are split into multiple messages, and error indexes are rewritten. An unordered batch continues on error and returns the error after all messages are sent.</p>
<p>Empty collection.</p>
<p>.. code:: javascript</p>
<pre><code>// Verify that the driver splits inserts into 16-MiB messages:
batch = initializeOrderedBulkOp()
for (i = 0; i &lt; 6; i++) {
batch.insert({_id: i, a: '4 MiB STRING'});
}

batch.insert({_id: 0})  // will fail
batch.insert({_id: 100})

batch.execute() fails with error details

error_details['nInserted'] == 6
error_details['writeErrors'].length == 1
error = error_details['writeErrors'][0]
error['code'] == 11000  // duplicate key
error['errmsg'] is a string.
error['index'] == 6  // properly rewritten error index

collection.count() == 6
</code></pre>
<p>Same for initializeUnorderedBulkOp, except:</p>
<p>.. code:: javascript</p>
<pre><code>error_details['nInserted'] == 7
collection.count() == 7
</code></pre>
<h2 id="batch-splitting-maxwritebatchsize"><a class="header" href="#batch-splitting-maxwritebatchsize">BATCH SPLITTING: maxWriteBatchSize</a></h2>
<p>More than 1000 documents to be inserted, updated, or removed are split into multiple messages, and error indexes are rewritten. An unordered batch continues on error and returns the error after all messages are sent. Similar test to the maxBsonObjectSize test. Note the server doesnt yet enforce the maxWriteBatchSize limit, so incorrect code will appear to succeed.</p>
<h2 id="re-running-a-batch"><a class="header" href="#re-running-a-batch">RE-RUNNING A BATCH</a></h2>
<p>A batch can only be executed once.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.insert({})
batch.execute()
batch.execute() a second time raises reasonable error.
</code></pre>
<p>Same for initializeUnorderedBulkOp().</p>
<h2 id="empty-batch"><a class="header" href="#empty-batch">EMPTY BATCH</a></h2>
<p>execute() throws if the batch is empty.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.execute() with no operations raises a reasonable error.
</code></pre>
<p>Same for initializeUnorderedBulkOp().</p>
<h2 id="no-journal"><a class="header" href="#no-journal">NO JOURNAL</a></h2>
<p>Attempting the 'j write concern with a write command on mongod 2.6 is an error if mongod is started with --nojournal. This applies to bulk operations with mongod 2.4 as well, even though it returns {ok: 1, jnote: "journaling not enabled on this server"}; the driver must detect this message and turn it into an error.</p>
<p>mongod started with --nojournal.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.insert({})
batch.execute({j: 1}) raises error.
</code></pre>
<p>Same for initializeUnorderedBulkOp().</p>
<h2 id="w--1-against-standalone"><a class="header" href="#w--1-against-standalone">W &gt; 1 AGAINST STANDALONE</a></h2>
<p>On both 2.4 and 2.6, attempting write concern w &gt; 1 against a non-replica-set mongod is an error.</p>
<p>Standalone mongod.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.insert({})
batch.execute({w: 2}) raises error.
</code></pre>
<p>Same for initializeUnorderedBulkOp().</p>
<h2 id="wtimeout-plus-duplicate-key-error"><a class="header" href="#wtimeout-plus-duplicate-key-error">WTIMEOUT PLUS DUPLICATE KEY ERROR</a></h2>
<p>A single unordered batch can report both writeErrors and writeConcernErrors.</p>
<p>2-node replica set.</p>
<p>Empty collection.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeUnorderedBulkOp()   
batch.insert({_id: 1})
batch.insert({_id: 1})
batch.execute({w: 3, wtimeout: 1}) raises error with details.
error_details['nInserted'] == 1
error_details['writeErrors'].length == 1
error_details['writeErrors'][0]['index'] == 1
// code 64, "timed out" in 2.4
// code 64, "waiting for replication timed out" in 2.6
// code 100, "Not enough data-bearing nodes" in 3.0
error_details['writeConcernErrors'][0]['code'] either 64 or 100
error_details['writeConcernErrors'][0]['errmsg'] not empty
</code></pre>
<h2 id="wtimeout-with-multiple-operations"><a class="header" href="#wtimeout-with-multiple-operations">WTIMEOUT WITH MULTIPLE OPERATIONS</a></h2>
<p>Multiple write concern errors are all reported.</p>
<p>2-node replica set.</p>
<p>Empty collection.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.insert({_id: 1})
batch.find({}).remove()
batch.execute({w: 3, wtimeout: 1}) raises error with details.
error_details['nInserted'] == 1
error_details['nRemoved'] == 1
error_details['writeErrors'].length == 0
// code 64, "timed out" in 2.4
// code 64, "waiting for replication timed out" in 2.6
// code 100, "Not enough data-bearing nodes" in 3.0

wc_errors = error_details['writeConcernErrors']
wc_errors.length == 2
for (i = 0; i &lt; 2; i++) {
  wc_errors[i]['code'] either 64 or 100
  wc_errors[i]['errmsg'] is not empty
}
</code></pre>
<h2 id="w--0"><a class="header" href="#w--0">W = 0</a></h2>
<p>A batch with w: 0 doesnt report write errors.</p>
<p>Empty collection.</p>
<p>.. code:: javascript</p>
<pre><code>batch = initializeOrderedBulkOp()
batch.insert({_id: 1})
batch.insert({_id: 1})
batch.execute({w: 0}) raises no error.
collection.count() == 1.
</code></pre>
<p>Same for initializeUnorderedBulkOp(), except collection.count() == 2.</p>
<h2 id="failover-with-mixed-versions"><a class="header" href="#failover-with-mixed-versions">FAILOVER WITH MIXED VERSIONS</a></h2>
<p>The driver detects when the primarys max wire protocol version increases or decreases, and the driver correctly switches between using write commands and using legacy write operations.</p>
<p>2-node replica set. One node runs 2.4, the other runs 2.6.</p>
<p>.. code:: javascript</p>
<pre><code>client = MongoReplicaSetClient()
// Switch primary:
client.admin.command({replSetStepDown: 5})  // cant be primary for 5 seconds

batch = client.db.collection.initializeOrderedBulkOp()
batch.insert({_id: 1})
batch.execute() should succeed
</code></pre>
<p>sleep 6 seconds</p>
<p>.. code:: javascript</p>
<pre><code>// Switch back to original primary
client.admin.command({replSetStepDown: 5})
batch = client.db.collection.initializeOrderedBulkOp()
batch.insert({_id: 2}).execute() should succeed
</code></pre>
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p>:2023-10-17: Updated <code>maxWriteBatchSize</code> default to 100,000 from 1000
:2022-10-05: Remove spec front matter and reformat changelog. Consolidated
changelog entries prior to the first published version of this
document, since exact dates were unavailable.
:2021-05-27: Removed "Test Case 3: Key validation, no $-prefixed keys allowed"
for insert.
:2015-10-23: Clarify that "writeConcernErrors" field is plural
:2015-05-22: * First public version of the specification.
* Deprecated this specification in favor of CRUD API.
* Merged in Test Cases from QA tickets.
* Specification cleanup and increased precision.
* Suggested error handling for languages using commonly raising
exceptions.
* Narrowed writeConcern reporting requirement.
* Renamed nUpdated to nMatched as to reflect that it's the number
of matched documents not the number of modified documents.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="server_write_commands.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="crud/bulk-write.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="server_write_commands.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="crud/bulk-write.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
